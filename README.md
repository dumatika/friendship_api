# Friendship API

Эталонное решение задачи "API для друзей" в
рамках [тестового задания](https://gist.github.com/k0t3n/99e60365ccb66cfa259f67e76fcfccca) на летнюю стажировку
JetBrains в **Сервис для обучения математике: Python Backend**.

## Models

### User

В Django уже есть [стандартная модель пользователя](https://docs.djangoproject.com/en/3.2/topics/auth/customizing/).
Нужно было её переопределить и добавить рекурсивную many-to-many связь.

### Friendship

Связь между пользователями (M2M) необходимо было объявить явно: это даст понимание используемой связи для Django и
позволит использовать оптимизации фреймворка. **Важно: так как рекурсивная M2M-связь создает 2 записи в промежуточной
таблице, то для корректности данных нужно передавать аргумент `through_defaults` со значением для поля `created_at`, в
противном случае время создание дружбы будет отличаться для двух друзей.**
Помимо этого лучше всего было на уровне БД написать ограничения для данных. Например, запретить дублирование записей о
дружбе (`UniqueTogether`) и запретить дружбу самим с собой
(`CheckConstraint`).

## Serializers

Для пользователя нужно было создать 4 сериализатора:

* `UserSerializer` - list
* `UserDetailedSerializer` (nested `FriendSerializer`&`FriendOfFriendSerializer`) - retrieve, update

Так же можно было создать рекурсивные сериализаторы с помощи
библиотеки [django-rest-framework-recursive](https://github.com/heywbj/django-rest-framework-recursive).

Для реализации обновления m2m связей использовать write only поле `friends_ids`. Для проверки совпадение редактируемого
объекта с текущим пользователем использовать permission.

## Views

Для текущей задачи мы вполне могли использовать viewsets. В зависимости от типа запроса нужно было отдавать разные
сериализаторы и формировать разные выборки с нужными джоинами.  
